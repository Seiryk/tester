<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body>
    <script>
      class Node {
        constructor(value, next) {
          this.value = value;
          this.next = next;
        }
      }

      class SinglyLinkedList {
        constructor(value, next) {
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        push(val) {
          const newNode = new Node(val);
          if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
          } else {
            this.tail.next = newNode;
            this.tail = newNode;
          }
          this.length++;
          return this;
        }

        shift() {
          if (!this.head) return undefined;
          const newHead = this.head.next;
          this.head = newHead;
          length--;
          if (this.length === 0) {
            this.tail = null;
          }
          return this.head;
        }

        unshift(val) {
          const newNode = new Node(val);
          newNode.next = this.head;
          if (!this.head) {
            this.tail = newNode;
          }
          this.head = newNode;
          this.length++;
          return this.head;
        }

        get(idx) {
          if (idx >= this.length || idx < 0) {
            return null;
          }
          let current = this.head;
          let i = 0;
          while (i !== idx) {
            current = current.next;
            i++;
          }
          return current;
        }

        set(val, idx) {
          const element = this.get(idx);
          if (!element) {
            return null;
          }
          element.value = val;
          return true;
        }

        insert(index, value) {
          if (index < 0 || index > this.length) return false;
          if (index === this.length) return this.push(value);
          if (index === 0) return this.unshift(value);
          const newNode = new Node(value);
          const prev = this.get(index - 1);
          const next = prev.next;
          prev.next = newNode;
          newNode.next = next;
          this.length++;
          return true;
        }

        remove(idx) {
          if (idx < 0 || idx >= this.length) return false;
          if (idx === this.length - 1) return this.pop(idx);
          if (idx === 0) return this.shift(idx);
          const prev = this.get(idx - 1);
          const next = prev.next.next;
          prev.next = next;
          this.length--;
          return true;
        }

        reverse() {
          let node = this.head;
          this.head = this.tail;
          this.tail = node;
          let i = 0;
          let next;
          let prev = null;
          while (i < this.length) {
            debugger;
            next = node.next;
            node.next = prev;
            prev = node;
            node = next;

            i++;
          }
          return this;
        }

        pop() {
          if (!this.head) {
            return undefined;
          }
          let current = this.head;
          let newTail = current;
          while (current.next) {
            newTail = current;
            current = current.next;
          }
          this.tail = newTail;
          this.tail.next = null;
          this.length--;
          return current;
        }
      }
      let list = new SinglyLinkedList();
      list.push(1);
      list.push(2);
      list.push(3);

      // class Node {
      //     constructor(value) {
      //         this.value = value;
      //         this.next = null;
      //         this.prev = null;
      //     }
      // }

      // class DablLinkedList {
      //     constructor(props) {
      //         this.head = null;
      //         this.tail = null;
      //         this.length = 0;
      //     }

      //     push(val) {
      //         const newNode = new Node(val);
      //         if (!this.head) {
      //             this.head = newNode;
      //             this.tail = newNode;
      //         } else {
      //             this.tail.next = newNode;
      //             newNode.prev = this.tail;
      //             this.tail = newNode;
      //         }
      //         this.length++;
      //         return this;
      //     }
      //     pop() {
      //         if (!this.head) return undefined;
      //         const newTail = this.tail;
      //         if (this.length === 1) {
      //             this.tail = null;
      //             this.head = null;
      //             this.length--;
      //             return newTail;
      //         };
      //         this.tail = newTail.prev;
      //         this.tail.next = null;
      //         newTail.prev = null;
      //         this.length--;
      //         return newTail;
      //     }

      //     shift() {
      //         if (!this.head) return undefined;
      //         const shiftedEl = this.head;
      //         if (this.length === 1) {
      //             this.tail = null;
      //             this.head = null;
      //         } else {
      //             this.head = shiftedEl.next;
      //             this.head.prev = null;
      //             shiftedEl.next = null;
      //         }
      //         this.length--;
      //         return shiftedEl;
      //     }
      // }

      // const list = new DablLinkedList();
      // list.push(1);
      // list.push(2);
      // list.push(3);
      // list.push(4);
    </script>
  </body>
</html>
